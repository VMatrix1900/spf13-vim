" Modeline and Notes {
" vim: set sw=4 ts=4 sts=4 et tw=78 foldmarker={,} foldlevel=0 foldmethod=marker spell:
"
"                    __ _ _____              _
"         ___ _ __  / _/ |___ /      __   __(_)_ __ ___
"        / __| '_ \| |_| | |_ \ _____\ \ / /| | '_ ` _ \
"        \__ \ |_) |  _| |___) |_____|\ V / | | | | | | |
"        |___/ .__/|_| |_|____/        \_/  |_|_| |_| |_|
"            |_|
"
"   This is the personal .vimrc.bundles file of Steve Francia.
"   While much of it is beneficial for general use, I would
"   recommend picking out the parts you want and understand.
"
"   This file imports the various plugins of spf13. If you
"   wish to alter which groups are imported, see vimrc.before.
"   If you wish to add or remove individual bundles, create
"   ~/.vimrc.bundles.local and `Bundle` or `UnBundle` as needed
"   from there.
"
"   You can find me at http://spf13.com
" }

" Environment {

    " Basics {
        set nocompatible        " Must be first line
        set background=dark     " Assume a dark background
    " }

    " Windows Compatible {
        " On Windows, also use '.vim' instead of 'vimfiles'; this makes synchronization
        " across (heterogeneous) systems easier.
        if has('win32') || has('win64')
          set runtimepath=$HOME/.vim,$VIM/vimfiles,$VIMRUNTIME,$VIM/vimfiles/after,$HOME/.vim/after

          " Be nice and check for multi_byte even if the config requires
          " multi_byte support most of the time
          if has("multi_byte")
            " Windows cmd.exe still uses cp850. If Windows ever moved to
            " Powershell as the primary terminal, this would be utf-8
            set termencoding=cp850
            " Let Vim use utf-8 internally, because many scripts require this
            set encoding=utf-8
            setglobal fileencoding=utf-8
            " Windows has traditionally used cp1252, so it's probably wise to
            " fallback into cp1252 instead of eg. iso-8859-15.
            " Newer Windows files might contain utf-8 or utf-16 LE so we might
            " want to try them first.
            set fileencodings=ucs-bom,utf-8,utf-16le,cp1252,iso-8859-15
          endif
        endif
    " }

" }

call plug#begin('~/.vim/bundle')
" Bundles {

    " Deps {
        Plug 'MarcWeber/vim-addon-mw-utils'
        Plug 'tomtom/tlib_vim'
        if executable('ag')
            let g:ackprg = 'ag --nogroup --nocolor --column --smart-case'
        elseif executable('ack-grep')
            let g:ackprg="ack-grep -H --nocolor --nogroup --column"
        endif
    " }

    " In your .vimrc.before.local file
    " list only the plugin groups you will use
    if !exists('g:spf13_bundle_groups')
        let g:spf13_bundle_groups=['general', 'writing', 'ncm', 'programming', 'php', 'ruby', 'python', 'javascript', 'html', 'misc',]
    endif

    " General {
        if count(g:spf13_bundle_groups, 'general')
            Plug 'altercation/vim-colors-solarized'
            let g:solarized_termcolors=256
            let g:solarized_termtrans=1
            Plug 'tpope/vim-surround'
            Plug 'tpope/vim-repeat'
            Plug 'rhysd/conflict-marker.vim'
            Plug 'jiangmiao/auto-pairs'
            Plug 'terryma/vim-multiple-cursors'
            Plug 'xolox/vim-session'
            Plug 'xolox/vim-misc'
            set sessionoptions=blank,buffers,curdir,folds,tabpages,winsize

            Plug 'vim-scripts/matchit.zip'
            let b:match_ignorecase = 1

            if (has("python") || has("python3")) && exists('g:spf13_use_powerline') && !exists('g:spf13_use_old_powerline')
                Plug 'Lokaltog/powerline', {'rtp':'/powerline/bindings/vim'}
            elseif exists('g:spf13_use_powerline') && exists('g:spf13_use_old_powerline')
                Plug 'Lokaltog/vim-powerline'
            elseif exists('g:spf13_use_airline')
                Plug 'vim-airline/vim-airline'
                Plug 'vim-airline/vim-airline-themes'
                " Set configuration options for the statusline plugin vim-airline.
                " Use the powerline theme and optionally enable powerline symbols.
                " To use the symbols , , , , , , and .in the statusline
                " segments add the following to your .vimrc.before.local file:
                "   let g:airline_powerline_fonts=1
                " If the previous symbols do not render for you then install a
                " powerline enabled font.

                " See `:echo g:airline_theme_map` for some more choices
                " Default in terminal vim is 'dark'
                if !exists('g:airline_theme')
                    let g:airline_theme = 'solarized'
                endif
                if !exists('g:airline_powerline_fonts')
                    " Use the default set of separators with a few customizations
                    let g:airline_left_sep='›'  " Slightly fancier than '>'
                    let g:airline_right_sep='‹' " Slightly fancier than '<'
                endif
            else
                Plug 'itchyny/lightline.vim'
                Plug 'maximbaz/lightline-ale'
                let g:lightline = {
                            \ 'colorscheme': 'solarized',
                            \ 'active': {
                            \   'left': [ ['paste'],
                            \               [ 'gitbranch', 'readonly', 'filename', 'modified' ]],
                            \   'right': [ ['linter_errors', 'linter_warnings', 'linter_ok' ] ],
                            \},
                            \ 'component_function': {
                            \   'gitbranch': 'fugitive#head',
                            \},
                            \ 'component_expand': {
							\   'linter_warnings': 'lightline#ale#warnings',
							\   'linter_errors': 'lightline#ale#errors',
							\   'linter_ok': 'lightline#ale#ok',
							\},
                            \ 'component_type': {
							\   'linter_warnings': 'warning',
							\   'linter_errors': 'error',
							\   'linter_ok': 'left',
                            \},
                            \}
            endif
            Plug 'powerline/fonts'
            Plug 'bling/vim-bufferline'
            Plug 'easymotion/vim-easymotion'
            Plug 'mbbill/undotree'
            nnoremap <Leader>u :UndotreeToggle<CR>
            " If undotree is opened, it is likely one wants to interact with it.
            let g:undotree_SetFocusWhenToggle=1

            Plug 'nathanaelkane/vim-indent-guides'
            let g:indent_guides_start_level = 2
            let g:indent_guides_guide_size = 1
            let g:indent_guides_enable_on_vim_startup = 1

            if !exists('g:spf13_no_views')
                Plug 'vim-scripts/restore_view.vim'
            endif
            Plug 'mhinz/vim-signify'
            Plug 'tpope/vim-abolish'
            Plug 'osyo-manga/vim-over'
            Plug 'kana/vim-textobj-user'
            Plug 'kana/vim-textobj-indent'
            Plug 'gcmt/wildfire.vim'
            let g:wildfire_objects = {
                        \ "*" : ["i'", 'i"', "i)", "i]", "i}", "ip"],
                        \ "html,xml" : ["at"],
                        \ }

        endif
    " }

    " Writing {
        if count(g:spf13_bundle_groups, 'writing')
            Plug 'reedes/vim-litecorrect'
            Plug 'reedes/vim-textobj-sentence'
            Plug 'reedes/vim-textobj-quote'
            Plug 'reedes/vim-wordy'

            augroup textobj_sentence
              autocmd!
              autocmd FileType markdown call textobj#sentence#init()
              autocmd FileType textile call textobj#sentence#init()
              autocmd FileType text call textobj#sentence#init()
            augroup END

            augroup textobj_quote
                autocmd!
                autocmd FileType markdown call textobj#quote#init()
                autocmd FileType textile call textobj#quote#init()
                autocmd FileType text call textobj#quote#init({'educate': 0})
            augroup END
        endif
    " }

    " General Programming {
        if count(g:spf13_bundle_groups, 'programming')
            " Pick one of the checksyntax, jslint, or syntastic
            Plug 'w0rp/ale'
            Plug 'tpope/vim-fugitive'
            Plug 'mattn/webapi-vim'
            Plug 'mattn/gist-vim'
            Plug 'godlygeek/tabular'
            nmap <Leader>a& :Tabularize /&<CR>
            vmap <Leader>a& :Tabularize /&<CR>
            nmap <Leader>a= :Tabularize /^[^=]*\zs=<CR>
            vmap <Leader>a= :Tabularize /^[^=]*\zs=<CR>
            nmap <Leader>a=> :Tabularize /=><CR>
            vmap <Leader>a=> :Tabularize /=><CR>
            nmap <Leader>a: :Tabularize /:<CR>
            vmap <Leader>a: :Tabularize /:<CR>
            nmap <Leader>a:: :Tabularize /:\zs<CR>
            vmap <Leader>a:: :Tabularize /:\zs<CR>
            nmap <Leader>a, :Tabularize /,<CR>
            vmap <Leader>a, :Tabularize /,<CR>
            nmap <Leader>a,, :Tabularize /,\zs<CR>
            vmap <Leader>a,, :Tabularize /,\zs<CR>
            nmap <Leader>a<Bar> :Tabularize /<Bar><CR>
            vmap <Leader>a<Bar> :Tabularize /<Bar><CR>

            Plug 'tomtom/tcomment_vim'
            Plug 'luochen1990/rainbow'
            let g:rainbow_active = 1 "0 if you want to enable it later via :RainbowToggle

            Plug 'majutsushi/tagbar'
            nnoremap <silent> <leader>tt :TagbarToggle<CR>

            Plug 'brookhong/cscope.vim'
        endif
    " }

    " Snippets & AutoComplete {
        if count(g:spf13_bundle_groups, 'snipmate')
            Plug 'garbas/vim-snipmate'
            " Setting the author var
            " If forking, please overwrite in your .vimrc.local file
            let g:snips_author = 'Steve Francia <steve.francia@gmail.com>'

            Plug 'honza/vim-snippets'
            " Source support_function.vim to support vim-snippets.
            if filereadable(expand("~/.vim/bundle/vim-snippets/snippets/support_functions.vim"))
                source ~/.vim/bundle/vim-snippets/snippets/support_functions.vim
            endif
        elseif count(g:spf13_bundle_groups, 'youcompleteme')
            Plug 'Valloric/YouCompleteMe'
            Plug 'SirVer/ultisnips'
            Plug 'honza/vim-snippets'

            let g:acp_enableAtStartup = 0

            " enable completion from tags
            let g:ycm_collect_identifiers_from_tags_files = 1

            " enable complete when 2 characters are typed.
            let g:ycm_semantic_triggers =  {
			\ 'c,cpp,python,java,go,erlang,perl': ['re!\w{2}'],
			\ 'cs,lua,javascript': ['re!\w{2}'],
			\ }


            " remap Ultisnips for compatibility for YCM
            let g:UltiSnipsExpandTrigger = '<C-j>'
            let g:UltiSnipsJumpForwardTrigger = '<C-j>'
            let g:UltiSnipsJumpBackwardTrigger = '<C-k>'

            " Enable omni completion.
            autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
            autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
            autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
            autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
            autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete
            autocmd FileType haskell setlocal omnifunc=necoghc#omnifunc

            " Haskell post write lint and check with ghcmod
            " $ `cabal install ghcmod` if missing and ensure
            " ~/.cabal/bin is in your $PATH.
            if !executable("ghcmod")
                autocmd BufWritePost *.hs GhcModCheckAndLintAsync
            endif

            " For snippet_complete marker.
            if !exists("g:spf13_no_conceal")
                if has('conceal')
                    set conceallevel=2 concealcursor=i
                endif
            endif

            " Disable the neosnippet preview candidate window
            " When enabled, there can be too much visual noise
            " especially when splits are used.
            set completeopt-=preview

        elseif count(g:spf13_bundle_groups, 'deoplete')
            if has('nvim')
                Plug 'Shougo/deoplete.nvim', { 'do': ':UpdateRemotePlugins' }
            else
                Plug 'Shougo/deoplete.nvim'
                Plug 'roxma/nvim-yarp'
                Plug 'roxma/vim-hug-neovim-rpc', { 'do': 'pip3 install --upgrade neovim' }
            endif
            let g:deoplete#enable_at_startup = 1
            let g:deoplete#auto_complete_start_length = 1
            let g:deoplete#enable_smart_case = 1
            Plug 'Shougo/neosnippet'
            Plug 'Shougo/neosnippet-snippets'
            Plug 'honza/vim-snippets'
            let g:AutoPairsMapCR=0
            imap <C-k>     <Plug>(neosnippet_expand_or_jump)
            smap <C-k>     <Plug>(neosnippet_expand_or_jump)
            xmap <C-k>     <Plug>(neosnippet_expand_target)
            imap <expr><TAB> pumvisible() ? "\<C-n>" : (neosnippet#expandable_or_jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>")
            imap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<S-TAB>"
            imap <expr><CR> pumvisible() ? deoplete#mappings#close_popup() : "\<CR>\<Plug>AutoPairsReturn"
        elseif count(g:spf13_bundle_groups, 'ncm')
            Plug 'roxma/nvim-completion-manager'
            Plug 'SirVer/ultisnips'
            Plug 'honza/vim-snippets'
			let g:UltiSnipsExpandTrigger		= "<Plug>(ultisnips_expand)"
			let g:UltiSnipsJumpForwardTrigger	= "<c-j>"
			let g:UltiSnipsJumpBackwardTrigger	= "<c-k>"
			let g:UltiSnipsRemoveSelectModeMappings = 0
            imap <expr> <CR>  (pumvisible() ?  "\<c-y>\<Plug>(expand_or_nl)" : "\<CR>")
            imap <expr> <Plug>(expand_or_nl) (cm#completed_is_snippet() ? "\<c-u>":"\<CR>")
            " inoremap <expr> <Tab> pumvisible() ? "\<C-n>" : "\<Tab>"
            " inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
            if !has('nvim')
                Plug 'roxma/vim-hug-neovim-rpc', { 'do': 'pip3 install --upgrade neovim' }
            endif
        elseif count(g:spf13_bundle_groups, 'lsp')
            Plug 'prabirshrestha/asyncomplete.vim'
            Plug 'prabirshrestha/async.vim'
            Plug 'prabirshrestha/vim-lsp'
            Plug 'prabirshrestha/asyncomplete-lsp.vim'

            if executable('pyls')
                " pip install python-language-server
                au User lsp_setup call lsp#register_server({
                    \ 'name': 'pyls',
                    \ 'cmd': {server_info->['pyls']},
                    \ 'whitelist': ['python'],
                    \ })
            endif

            if executable('clangd')
                au User lsp_setup call lsp#register_server({
                    \ 'name': 'clangd',
                    \ 'cmd': {server_info->['clangd']},
                    \ 'whitelist': ['c', 'cpp', 'objc', 'objcpp'],
                    \ })
            endif

            if executable('docker-langserver')
                au User lsp_setup call lsp#register_server({
                    \ 'name': 'docker-langserver',
                    \ 'cmd': {server_info->[&shell, &shellcmdflag, 'docker-langserver --stdio']},
                    \ 'whitelist': ['dockerfile'],
                    \ })
            endif

            if executable('flow-language-server')
                au User lsp_setup call lsp#register_server({
                    \ 'name': 'flow-language-server',
                    \ 'cmd': {server_info->[&shell, &shellcmdflag, 'flow-language-server --stdio']},
                    \ 'root_uri':{server_info->lsp#utils#path_to_uri(lsp#utils#find_nearest_parent_file_directory(lsp#utils#get_buffer_path(), '.flowconfig'))},
                    \ 'whitelist': ['javascript'],
                    \ })
            endif

            if executable('go-langserver')
                au User lsp_setup call lsp#register_server({
                    \ 'name': 'go-langserver',
                    \ 'cmd': {server_info->['go-langserver', '-mode', 'stdio']},
                    \ 'whitelist': ['go'],
                    \ })
            endif

            if executable('rls')
                au User lsp_setup call lsp#register_server({
                    \ 'name': 'rls',
                    \ 'cmd': {server_info->['rustup', 'run', 'nightly', 'rls']},
                    \ 'whitelist': ['rust'],
                    \ })
            endif

            if executable('typescript-language-server')
                au User lsp_setup call lsp#register_server({
                    \ 'name': 'typescript-language-server',
                    \ 'cmd': {server_info->[&shell, &shellcmdflag, 'typescript-language-server --stdio']},
                    \ 'root_uri':{server_info->lsp#utils#path_to_uri(lsp#utils#find_nearest_parent_file_directory(lsp#utils#get_buffer_path(), 'tsconfig.json'))},
                    \ 'whitelist': ['typescript'],
                    \ })
            endif

            Plug 'SirVer/ultisnips'
            Plug 'honza/vim-snippets'
            Plug 'prabirshrestha/asyncomplete-ultisnips.vim'
            " remap Ultisnips for compatibility
            let g:UltiSnipsExpandTrigger = '<C-j>'
            let g:UltiSnipsJumpForwardTrigger = '<C-j>'
            let g:UltiSnipsJumpBackwardTrigger = '<C-k>'
            call asyncomplete#register_source(asyncomplete#sources#ultisnips#get_source_options({
                    \ 'name': 'ultisnips',
                    \ 'whitelist': ['*'],
                    \ 'completor': function('asyncomplete#sources#ultisnips#completor'),
                    \ }))
        endif
    " }

    " PHP {
        if count(g:spf13_bundle_groups, 'php')
            Plug 'spf13/PIV'
            let g:DisableAutoPHPFolding = 0
            let g:PIVAutoClose = 0

            Plug 'arnaud-lb/vim-php-namespace'
            Plug 'beyondwords/vim-twig'
        endif
    " }

    " Python {
        if count(g:spf13_bundle_groups, 'python')
            Plug 'yssource/python.vim'
            Plug 'vim-scripts/python_match.vim'
            
            if executable('yapf')
                autocmd FileType python set formatprg=yapf
            endif
        endif
    " }

    " Javascript {
        if count(g:spf13_bundle_groups, 'javascript')
            Plug 'elzr/vim-json'
            Plug 'groenewege/vim-less'
            Plug 'pangloss/vim-javascript'
            Plug 'briancollins/vim-jst'
            Plug 'kchmck/vim-coffee-script'
        endif
    " }

    " Scala {
        if count(g:spf13_bundle_groups, 'scala')
            Plug 'derekwyatt/vim-scala'
            Plug 'derekwyatt/vim-sbt'
        endif
    " }

    " Haskell {
        if count(g:spf13_bundle_groups, 'haskell')
            Plug 'travitch/hasksyn'
            Plug 'dag/vim2hs'
            Plug 'Twinside/vim-haskellConceal'
            Plug 'Twinside/vim-haskellFold'
            Plug 'lukerandall/haskellmode-vim'
            Plug 'eagletmt/neco-ghc'
            Plug 'eagletmt/ghcmod-vim'
            Plug 'Shougo/vimproc.vim'
            Plug 'adinapoli/cumino'
            Plug 'bitc/vim-hdevtools'
        endif
    " }

    " HTML {
        if count(g:spf13_bundle_groups, 'html')
            Plug 'heracek/HTML-AutoCloseTag'
            " Make it so AutoCloseTag works for xml and xhtml files as well
            au FileType xhtml,xml ru ftplugin/html/autoclosetag.vim
            nmap <Leader>ac <Plug>ToggleAutoCloseMappings

            Plug 'hail2u/vim-css3-syntax'
            Plug 'gorodinskiy/vim-coloresque'
            Plug 'tpope/vim-haml'
            Plug 'mattn/emmet-vim'
        endif
    " }

    " Ruby {
        if count(g:spf13_bundle_groups, 'ruby')
            Plug 'tpope/vim-rails'
            let g:rubycomplete_buffer_loading = 1
            "let g:rubycomplete_classes_in_global = 1
            "let g:rubycomplete_rails = 1
        endif
    " }

    " Puppet {
        if count(g:spf13_bundle_groups, 'puppet')
            Plug 'rodjek/vim-puppet'
        endif
    " }

    " Go Lang {
        if count(g:spf13_bundle_groups, 'go')
            Plug 'fatih/vim-go'
            let g:go_highlight_functions = 1
            let g:go_highlight_methods = 1
            let g:go_highlight_structs = 1
            let g:go_highlight_operators = 1
            let g:go_highlight_build_constraints = 1
            let g:go_fmt_command = "goimports"
            au FileType go nmap <Leader>s <Plug>(go-implements)
            au FileType go nmap <Leader>i <Plug>(go-info)
            au FileType go nmap <Leader>e <Plug>(go-rename)
            au FileType go nmap <leader>r <Plug>(go-run)
            au FileType go nmap <leader>b <Plug>(go-build)
            au FileType go nmap <leader>t <Plug>(go-test)
            au FileType go nmap <Leader>gd <Plug>(go-doc)
            au FileType go nmap <Leader>gv <Plug>(go-doc-vertical)
            au FileType go nmap <leader>co <Plug>(go-coverage)

        endif
    " }

    " Elixir {
        if count(g:spf13_bundle_groups, 'elixir')
            Plug 'elixir-lang/vim-elixir'
            Plug 'carlosgaldino/elixir-snippets'
            Plug 'mattreduce/vim-mix'
        endif
    " }

    " Misc {
        if count(g:spf13_bundle_groups, 'misc')
            Plug 'rust-lang/rust.vim'
            Plug 'tpope/vim-markdown'
            Plug 'spf13/vim-preview'
            Plug 'tpope/vim-cucumber'
            Plug 'cespare/vim-toml'
            Plug 'quentindecock/vim-cucumber-align-pipes'
            Plug 'saltstack/salt-vim'
        endif
    " }

" Use fork bundles config if available {
    if filereadable(expand("~/.vimrc.bundles.fork"))
        source ~/.vimrc.bundles.fork
    endif
" }

" Use local bundles config if available {
    if filereadable(expand("~/.vimrc.bundles.local"))
        source ~/.vimrc.bundles.local
    endif
" }

call plug#end()
